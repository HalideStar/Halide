#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <assert.h>

bool u_method_0(int den, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {	
	uint64_t result = num;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;
}

bool u_method_1(int den, int mul, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {
	uint64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max) return false;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;
}

bool u_method_2(int den, int mul, int sh_post, int bits) {
    int max = (1 << bits) - 1;
    for (int num = 0; num <= max; num++) {
	uint64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max) return false;
	result += (num - result)/2;
	if (result > max) return false;
	result >>= sh_post;
	if (num / den != result) return false;
    }
    return true;    
}


//LH
// Make this code able to build tables for division with halide modulus semantics also.
// However, I have not found a working method.
# define USE_MODULUS 0

int divide(int num, int den, int modulus)
{
    if (modulus) {
        int hmod = ((num % den) + den) % num; // This is how Halide implements % operator
        // The following line relies on the fact that int is large compared to the value of num.
        return (num - hmod) / den; // Calculate division result corresponding to the mod definition.
    }
    return num / den;
}

//LH
bool s_method_m0(int den, int mul, int sh_post, int bits, int modulus) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {
	int64_t result = num;
	result >>= sh_post;
	if (divide(num,den,modulus) != result) return false;
    }
    return true;
}

//LH: Add parameter modulus
bool s_method_0(int den, int mul, int sh_post, int bits, int modulus) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {
	int64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max || result < min) return false;
	result >>= sh_post;
    result += (num < 0 ? 1 : 0);
	if (divide(num,den,modulus) != result) return false;
    }
    return true;
}

//LH: Add parameter modulus
bool s_method_1(int den, int mul, int sh_post, int bits, int modulus) {
    int min = -(1 << (bits-1)), max = (1 << (bits-1))-1;
    for (int num = min; num <= max; num++) {
	int64_t result = num;
	result *= mul;
	result >>= bits;
	if (result > max || result < min) return false;
	result += num;
	if (result > max || result < min) return false;
	result >>= sh_post;
    if (! modulus)
        result += (num < 0 ? 1 : 0);
	if (divide(num,den,modulus) != result) return false;
    }
    return true;    
}


int main(int argc, char **argv) {
    /* This program computes a table to help us do cheap integer
        division by a constant. It is based on the paper "Division by
        Invariant Integers using Multiplication" by Granlund and
        Montgomery.
    */

    printf("/** \\file \n"
           " * Tables telling us how to do integer division\n"
           " * via fixed-point multiplication for various small\n"
           " * constants. This file is automatically generated\n"
           " * by find_inverse.c\n"
           " */\n"
           "namespace Halide {\n"
           "namespace Internal {\n"
           "namespace IntegerDivision {\n\n");
    
    for (int bits = 8; bits <= 16; bits += 8) {
	int s_min = -(1 << (bits-1));
	int s_max = (1 << (bits-1))-1;
	int u_max = (1 << bits)-1;
   	
	printf("int table_u%d[][3] = {\n", bits);
	for (int den = 2; den <= 64; den++) {
	    for (int shift = 0; shift < 8; shift++) {
		if (u_method_0(den, shift, bits)) {
		    printf("    {0, 0, %d},\n", shift);
		    goto next_unsigned;
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = 0; mul <= u_max; mul++) {
		    if (u_method_1(den, mul, shift, bits)) {
			printf("    {1, %d, %d},\n", mul, shift);
			goto next_unsigned;
		    }
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = 0; mul <= u_max; mul++) {
		    if (u_method_2(den, mul, shift, bits)) {
			printf("    {2, %d, %d},\n", mul, shift);
			goto next_unsigned;
		    }
		}
	    }
	    printf("ERROR! No solution found for unsigned %d\n", den);
	  next_unsigned:;
	}
	printf("};\n");
    for (int modulus = 0; modulus < 2; modulus++) { //LH
	printf("int table_s%s%d[][3] = {\n", modulus ? "m" : "", bits);
	for (int den = 2; den <= 64; den++) {

	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = s_min; mul <= s_max; mul++) {
		    if (s_method_m0(den, mul, shift, bits, modulus)) {
			printf("    {-1, %d, %d},\n", mul, shift);
			goto next_signed;
		    }
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = s_min; mul <= s_max; mul++) {
		    if (s_method_0(den, mul, shift, bits, modulus)) {
			printf("    {0, %d, %d},\n", mul, shift);
			goto next_signed;
		    }
		}
	    }
	    
	    for (int shift = 0; shift < 8; shift++) {
		for (int mul = s_min; mul <= s_max; mul++) {
		    if (s_method_1(den, mul, shift, bits, modulus)) {
			printf("    {1, %d, %d},\n", mul, shift);
			goto next_signed;
		    }
		}
	    }
	    printf("ERROR! No solution found for signed %d\n", den);
	  next_signed:;
	}
	printf("};\n"); 
#if ! USE_MODULUS
    break; //LH
#endif
    }
    }

    printf("}}}\n");

    return 0;
}
